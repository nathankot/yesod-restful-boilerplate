module TestExtension where

import           Application (makeFoundation)
import qualified Blaze.ByteString.Builder as Builder
import           ClassyPrelude
import qualified Control.Monad.Trans.State as ST
import           Data.Aeson (Value, eitherDecode)
import qualified Data.ByteString as S
import qualified Data.ByteString.Lazy.Char8 as BSL8
import qualified Data.List as DL
import qualified Data.Map as M
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import           Database.Persist hiding (get)
import           Database.Persist.Sql       (SqlBackend, SqlPersistM,
                                             connEscapeName, rawExecute, rawSql,
                                             runSqlPersistMPool, unSingle)
import           Foundation
import           Model
import           Model.ApiKey
import qualified Network.HTTP.Types as H
import           Network.HTTP.Types.Header (hAuthorization)
import qualified Network.Socket.Internal as Sock
import           Network.Wai (Request (..))
import           Network.Wai.Test as W
import           Test.Hspec
import           Test.HUnit (assertBool)
import           Text.Shakespeare.Text (st)
import           Yesod.Core.Handler (RedirectUrl (..), toTextUrl)
import           Yesod.Core.Unsafe (runFakeHandler)
import           Yesod.Default.Config2 (ignoreEnv, loadAppSettings)
import           Yesod.Test as Y

-- | This method unwraps the maybe results generated by the factories.
retrieve :: ( MonadIO m
            , PersistUnique backend
            , PersistEntityBackend a ~ backend
            , Functor m)
         => ReaderT backend m (Maybe (Entity a))
         -> ReaderT backend m (Entity a)

retrieve = (=<<) $ maybe (fail "Could not get entity") return

valueEquals :: String -> Value -> YesodExample site ()
valueEquals t v = valueSatisfies t (v==)

valueSatisfies :: String -> (Value -> Bool) -> YesodExample site ()
valueSatisfies t p = withResponse $ \res ->
    liftIO $ assertBool t $
           case eitherDecode $ simpleBody res of
             Right v -> p v
             Left _ -> False

boolIsTrue :: String -> Bool -> YesodExample site ()
boolIsTrue s b = liftIO $ assertBool s b

boolIsFalse :: String -> Bool -> YesodExample site ()
boolIsFalse s b = liftIO $ assertBool s (not b)

requestJSON :: RequestBuilder App () -> YesodExample App ()
requestJSON b = Y.request $ addJSONHeader >> b

requestJSONWithUser :: Entity User -> RequestBuilder App () -> YesodExample App ()
requestJSONWithUser u b = do
  Entity _ k <- runDB $ generateApiKeyForUser u
  requestJSON $ addRequestHeader (hAuthorization, fromString $ "Bearer " ++ (unpack $ apiKeyValue k)) >> b

-- | Make a binary upload test request.
--
-- Does not use any yesod wrappers because this isn't
-- a traditional form request.
uploadRequestWithUser :: (RedirectUrl App url)
                         => Entity User -- ^ The user to make the request as
                         -> url  -- ^ The request url
                         -> H.Method -- ^ Request method
                         -> S.ByteString -- ^ Content type
                         -> BSL8.ByteString -- ^ Request body contents
                         -> YesodExample App ()
uploadRequestWithUser user u m ct b = do
    Entity _ k <- runDB $ generateApiKeyForUser user
    YesodExampleData app site cookies _ <- ST.get
    eurl <- runFakeHandler M.empty (\_ -> error "Yesod.Test: No logger available") site (toTextUrl u)
    url' <- either (error . show) return eurl
    let (urlPath, _) = T.break (== '?') url'
    let url = case DL.filter (/="") $ H.decodePathSegments $ TE.encodeUtf8 urlPath of
          ("http:":_:rest) -> rest
          ("https:":_:rest) -> rest
          x -> x
    let path = TE.decodeUtf8 $ Builder.toByteString $ H.encodePathSegments url
    let req = defaultRequest { requestMethod = m
                             , remoteHost = Sock.SockAddrInet 1 2
                             , requestHeaders = [ (H.hAuthorization, fromString $ "Bearer " ++ (unpack $ apiKeyValue k))
                                                , (H.hContentType, ct)
                                                , (H.hAccept, "application/json")]
                             , rawPathInfo = TE.encodeUtf8 path
                             , pathInfo = H.decodePathSegments$ TE.encodeUtf8 path
                             , rawQueryString = ""
                             , queryString = []
                             }
    let sreq = SRequest req b
    response <- liftIO $ runSession (srequest sreq
                                    { simpleRequest = (simpleRequest sreq)
                                      { httpVersion = H.http11 }
                                    }) app
    ST.put $ YesodExampleData app site cookies $ Just response

addJSONHeader :: RequestBuilder App ()
addJSONHeader = addRequestHeader (H.hAccept, "application/json")

runDB :: SqlPersistM a -> YesodExample App a
runDB query = do
    app <- getTestYesod
    liftIO $ runDBWithApp app query

runDBWithApp :: App -> SqlPersistM a -> IO a
runDBWithApp app query = runSqlPersistMPool query (appConnPool app)


withApp :: SpecWith App -> Spec
withApp = before $ do
    settings <- loadAppSettings
        ["config/test-settings.yml", "config/settings.yml"]
        []
        ignoreEnv
    foundation <- makeFoundation settings
    wipeDB foundation
    return foundation

-- This function will truncate all of the tables in your database.
-- 'withApp' calls it before each test, creating a clean environment for each
-- spec to run in.
wipeDB :: App -> IO ()
wipeDB app = runDBWithApp app $ do
    tables <- getTables
    sqlBackend <- ask

    let escapedTables = map (connEscapeName sqlBackend . DBName) tables
        query = "TRUNCATE TABLE " ++ intercalate ", " escapedTables
    rawExecute query []

getTables :: MonadIO m => ReaderT SqlBackend m [Text]
getTables = do
    tables <- rawSql [st|
        SELECT table_name
        FROM information_schema.tables
        WHERE table_schema = 'public' AND
              table_name  != 'installed_migrations';
    |] []

    return $ map unSingle tables
